// ==UserScript==
// @name         Templerun Auto-Complete+ (ê¸°ì¡´ cacì½”ë“œ ì œì™¸ë²„ì „)
// @namespace    http://tampermonkey.net/
// @version      2.9.1
// @description  Auto-completes Templerun questions with enhanced features
// @author       You
// @match        *://*/*
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_addStyle
// @grant        GM_registerMenuCommand
// @run-at       document-start
// ==/UserScript==

(function() {
    'use strict';

    // Configuration
    const CONFIG = {
        DEBUG: false,
        AUTO_SUBMIT: true,
        DELAY_MIN: 100,
        DELAY_MAX: 300,
        HIGHLIGHT_COLOR: '#90EE90'
    };

    // Utility functions
    const log = (...args) => CONFIG.DEBUG && console.log('[Templerun AC+]', ...args);
    const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    const randomDelay = () => delay(Math.random() * (CONFIG.DELAY_MAX - CONFIG.DELAY_MIN) + CONFIG.DELAY_MIN);

    // Answer database
    let answerDB = GM_getValue('answerDB', {});

    // Save answer to database
    function saveAnswer(question, answer) {
        const key = question.trim().toLowerCase();
        answerDB[key] = answer;
        GM_setValue('answerDB', answerDB);
        log('Saved answer:', key, '->', answer);
    }

    // Get answer from database
    function getAnswer(question) {
        const key = question.trim().toLowerCase();
        return answerDB[key] || null;
    }

    // Find question element
    function findQuestionElement() {
        const selectors = [
            '.question-text',
            '.quiz-question',
            '[data-question]',
            '.prompt-text',
            'h1.question',
            'h2.question',
            '.question-container p',
            '.question-wrapper'
        ];

        for (const selector of selectors) {
            const el = document.querySelector(selector);
            if (el && el.textContent.trim()) {
                return el;
            }
        }
        return null;
    }

    // Find answer input elements
    function findAnswerInputs() {
        return document.querySelectorAll([
            'input[type="text"]:not([readonly])',
            'input[type="radio"]',
            'input[type="checkbox"]',
            'textarea',
            '.answer-option',
            '[data-answer]',
            '.choice-item'
        ].join(', '));
    }

    // Find submit button
    function findSubmitButton() {
        const selectors = [
            'button[type="submit"]',
            'input[type="submit"]',
            '.submit-btn',
            '.next-btn',
            'button.primary',
            '[data-submit]',
            'button:contains("Submit")',
            'button:contains("Next")'
        ];

        for (const selector of selectors) {
            try {
                const el = document.querySelector(selector);
                if (el) return el;
            } catch (e) {
                // Handle invalid selectors
            }
        }

        // Fallback: find button with submit-like text
        const buttons = document.querySelectorAll('button, input[type="button"]');
        for (const btn of buttons) {
            const text = btn.textContent.toLowerCase();
            if (text.includes('submit') || text.includes('next') || text.includes('continue')) {
                return btn;
            }
        }
        return null;
    }

    // Fill answer
    async function fillAnswer(input, answer) {
        if (input.type === 'text' || input.tagName === 'TEXTAREA') {
            input.focus();
            input.value = answer;
            input.dispatchEvent(new Event('input', { bubbles: true }));
            input.dispatchEvent(new Event('change', { bubbles: true }));
        } else if (input.type === 'radio' || input.type === 'checkbox') {
            if (input.value === answer || input.parentElement.textContent.includes(answer)) {
                input.checked = true;
                input.dispatchEvent(new Event('change', { bubbles: true }));
            }
        } else if (input.classList.contains('answer-option') || input.classList.contains('choice-item')) {
            if (input.textContent.includes(answer)) {
                input.click();
            }
        }
        input.style.backgroundColor = CONFIG.HIGHLIGHT_COLOR;
    }

    // Auto-complete function
    async function autoComplete() {
        const questionEl = findQuestionElement();
        if (!questionEl) {
            log('No question found');
            return;
        }

        const question = questionEl.textContent.trim();
        const savedAnswer = getAnswer(question);

        if (savedAnswer) {
            log('Found saved answer:', savedAnswer);
            const inputs = findAnswerInputs();

            for (const input of inputs) {
                await fillAnswer(input, savedAnswer);
                await randomDelay();
            }

            if (CONFIG.AUTO_SUBMIT) {
                const submitBtn = findSubmitButton();
                if (submitBtn) {
                    await delay(500);
                    submitBtn.click();
                    log('Auto-submitted');
                }
            }
        } else {
            log('No saved answer for:', question);
        }
    }

    // Learn mode - capture correct answers
    function learnFromPage() {
        const questionEl = findQuestionElement();
        const correctEl = document.querySelector('.correct-answer, .right-answer, [data-correct="true"], .success');

        if (questionEl && correctEl) {
            const question = questionEl.textContent.trim();
            const answer = correctEl.textContent.trim();
            saveAnswer(question, answer);
        }
    }

    // Settings panel
    function createSettingsPanel() {
        const panel = document.createElement('div');
        panel.id = 'autocomplete_settings';
        panel.innerHTML = `
            <style>
                #autocomplete_settings {
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: #2d2d2d;
                    color: #fff;
                    padding: 20px;
                    border-radius: 10px;
                    z-index: 999999;
                    min-width: 300px;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
                    font-family: Arial, sans-serif;
                    display: none;
                }
                #autocomplete_settings.opened {
                    display: block;
                }
                #autocomplete_settings h3 {
                    margin: 0 0 15px 0;
                    color: #4CAF50;
                }
                #autocomplete_settings label {
                    display: block;
                    margin: 10px 0;
                }
                #autocomplete_settings input[type="checkbox"] {
                    margin-right: 10px;
                }
                #autocomplete_settings input[type="number"] {
                    width: 60px;
                    padding: 5px;
                    margin: 0 5px;
                }
                #autocomplete_settings button {
                    background: #4CAF50;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 5px;
                    cursor: pointer;
                    margin: 5px;
                }
                #autocomplete_settings button:hover {
                    background: #45a049;
                }
                #autocomplete_settings button.danger {
                    background: #f44336;
                }
                #autocomplete_settings button.danger:hover {
                    background: #da190b;
                }
                #autocomplete_settings .close-btn {
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    background: none;
                    border: none;
                    color: #fff;
                    font-size: 20px;
                    cursor: pointer;
                }
            </style>
            <button class="close-btn">&times;</button>
            <h3>ðŸŽ® Templerun Auto-Complete+</h3>
            <label>
                <input type="checkbox" id="ac_debug" ${CONFIG.DEBUG ? 'checked' : ''}>
                Debug Mode
            </label>
            <label>
                <input type="checkbox" id="ac_autosubmit" ${CONFIG.AUTO_SUBMIT ? 'checked' : ''}>
                Auto Submit
            </label>
            <label>
                Delay:
                <input type="number" id="ac_delay_min" value="${CONFIG.DELAY_MIN}" min="0" max="1000">
                -
                <input type="number" id="ac_delay_max" value="${CONFIG.DELAY_MAX}" min="0" max="2000">
                ms
            </label>
            <div style="margin-top: 15px;">
                <button id="ac_save">Save Settings</button>
                <button id="ac_export">Export DB</button>
                <button id="ac_import">Import DB</button>
                <button id="ac_clear" class="danger">Clear DB</button>
            </div>
            <div style="margin-top: 10px; font-size: 12px; color: #888;">
                Answers in DB: <span id="ac_count">${Object.keys(answerDB).length}</span>
            </div>
        `;

        document.body.appendChild(panel);

        // Event listeners
        panel.querySelector('.close-btn').addEventListener('click', () => {
            panel.classList.remove('opened');
        });

        panel.querySelector('#ac_save').addEventListener('click', () => {
            CONFIG.DEBUG = panel.querySelector('#ac_debug').checked;
            CONFIG.AUTO_SUBMIT = panel.querySelector('#ac_autosubmit').checked;
            CONFIG.DELAY_MIN = parseInt(panel.querySelector('#ac_delay_min').value);
            CONFIG.DELAY_MAX = parseInt(panel.querySelector('#ac_delay_max').value);
            GM_setValue('config', CONFIG);
            alert('Settings saved!');
        });

        panel.querySelector('#ac_export').addEventListener('click', () => {
            const data = JSON.stringify(answerDB, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'templerun_answers.json';
            a.click();
        });

        panel.querySelector('#ac_import').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const imported = JSON.parse(event.target.result);
                        answerDB = { ...answerDB, ...imported };
                        GM_setValue('answerDB', answerDB);
                        panel.querySelector('#ac_count').textContent = Object.keys(answerDB).length;
                        alert('Import successful!');
                    } catch (err) {
                        alert('Import failed: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        });

        panel.querySelector('#ac_clear').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all saved answers?')) {
                answerDB = {};
                GM_setValue('answerDB', answerDB);
                panel.querySelector('#ac_count').textContent = '0';
                alert('Database cleared!');
            }
        });

        return panel;
    }

    // Toggle settings panel
    function toggleSettings() {
        let panel = document.querySelector('#autocomplete_settings');
        if (!panel) {
            panel = createSettingsPanel();
        }
        panel.classList.toggle('opened');
    }

    // Initialize
    function init() {
        log('Initializing Templerun Auto-Complete+');

        // Load saved config
        const savedConfig = GM_getValue('config', null);
        if (savedConfig) {
            Object.assign(CONFIG, savedConfig);
        }

        // Register menu command
        if (typeof GM_registerMenuCommand !== 'undefined') {
            GM_registerMenuCommand('âš™ï¸ Settings', toggleSettings);
            GM_registerMenuCommand('â–¶ï¸ Run Auto-Complete', autoComplete);
            GM_registerMenuCommand('ðŸ“š Learn from Page', learnFromPage);
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.altKey && e.key === 'a') {
                autoComplete();
            } else if (e.altKey && e.key === 's') {
                toggleSettings();
            } else if (e.altKey && e.key === 'l') {
                learnFromPage();
            }
        });

        // Auto-run on page load
        if (document.readyState === 'complete') {
            setTimeout(autoComplete, 1000);
        } else {
            window.addEventListener('load', () => setTimeout(autoComplete, 1000));
        }

        // Observer for dynamic content
        const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                if (mutation.addedNodes.length) {
                    learnFromPage();
                }
            }
        });

        observer.observe(document.body || document.documentElement, {
            childList: true,
            subtree: true
        });

        log('Initialization complete');
    }

    // Start when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

})();

// YouTube-specific escape key handler
if (location.hostname.includes('youtube.com')) {
  window.top.document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      document.querySelectorAll('#autocomplete_settings').forEach(el => {
        el.classList.remove('opened');
      });
      window.top.document.querySelectorAll('#autocomplete_settings').forEach(el => {
        el.classList.remove('opened');
      });
    }
  });
}
